#include <array>
#include <print>
#include <ranges>
#include <tuple>
#include <vector>

auto main() -> int {

  namespace views = std::views;
  namespace ranges = std::ranges;

  using std::println;
  using std::views::zip;

  std::array<std::string, 4> names{"Ana", "Maria", "Pedro", "Paulo"};
  std::array<int, 4> ages{18, 20, 30, 25};
  std::array<double, 4> salaries{55000.0, 72050.0, 6000.0, 15700.0};

  double factor{0.15}; // 15%
  auto salary_bonus =
      views::zip_transform([&](double s) { return s * factor; }, salaries);

  auto print_header = [&](int number) {
    println();
    println("Option {}", number);
    println("{:<10} {:>5} {:>10} {:>10} ({}%)", "Name", "Age", "Salary",
            "Bonus", factor * 100);
  };

  // Option 1 uses C++20/C++23 Ranges pipelines to process the data in
  // real time, without creating an intermediate copy of the result table.
  print_header(1);
  for (const auto &[name, age, salary, bonus] :
       zip(names, ages, salaries, salary_bonus)) {
    println("{:<10} {:>5} {:>10.2f} {:>10.2f}", name, age, salary, bonus);
  }

  // Option 2 uses the same logic as Ranges, but materializes the result of the
  // View (employee_view) into a storage container (std::vector<EmployeeTuple>)
  // using std::ranges::to (C++23).
  auto employee_view = zip(names, ages, salaries, salary_bonus);

  using EmployeeTuple = std::tuple<std::string, int, double, double>;
  std::vector<EmployeeTuple> empleyee_records =
      employee_view | ranges::to<std::vector<EmployeeTuple>>();

  print_header(2);
  for (const auto &[name, age, salary, bonus] : empleyee_records) {
    println("{:<10} {:>5} {:>10.2f} {:>10.2f}", name, age, salary, bonus);
  }

  // Option 3 uses complex structures
  struct EmployeeStruct {
    std::string name;
    int age;
    double salary;
    double bonus;
  };

  std::vector<EmployeeStruct> employee_records_struct =
      // 1. Tuple
      employee_view
      // 2. Convert a tuple generated by zip into an Employee Struct.
      | views::transform([](const auto &t) {
          const auto &[n, a, s, b] = t;
          return EmployeeStruct{n, a, s, b};
        })
      // 3. ranges::to: Materializes the new range of structs into a vector.
      | ranges::to<std::vector<EmployeeStruct>>();

  print_header(3);
  for (const auto &[name, age, salary, bonus] : employee_records_struct) {
    println("{:<10} {:>5} {:>10.2f} {:>10.2f}", name, age, salary, bonus);
  }

  return 0;
}
